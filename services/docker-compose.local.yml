# This config shall not be used alone but after docker-compose.yml
#
# NOTES:
# - Overrides docker-compose.yml config when deploying services locally
# - Should not introduce a substantial different with respect the configuration deployed
# - Added ports to enforce they are published in the swarm (e.g. for integration testing).
# - sidecar cannot publish port with ingress mode since it can't be used with dnsrr mode
# - Port bindings "800X:8000" reserved for rest apis (e.g. /docs, /redoc)
# - Port bindings "300X:3000" reserved for remote debugging
#   - debug mode can be activated if SC_BOOT_MODE=debug-ptvsd (this is the default in devel).
#   - use vscode debugger "Python: Remote Attach *" config in  ''.vscode-template/launch.json'
#
version: "3.7"
services:
  catalog:
    environment:
      - SC_BOOT_MODE=${SC_BOOT_MODE:-default}
    ports:
      - "8005:8000"
      - "3005:3000"

  director:
    environment:
      - SC_BOOT_MODE=${SC_BOOT_MODE:-default}
      - SWARM_STACK_NAME=${SWARM_STACK_NAME:-simcore_local}
    ports:
      - "8080"
      - "3004:3000"
    # TODO: disable all pdb-debug modes if not used !!!
    #stdin_open: true
    #tty: true

  storage:
    environment:
      - SC_BOOT_MODE=${SC_BOOT_MODE:-default}
    ports:
      - "8080"
      - "3003:3000"

  webserver:
    environment:
      - SC_BOOT_MODE=${SC_BOOT_MODE:-default}
    ports:
      - "8080"
      - "3001:3000"

  sidecar_gpu:
    image: ${DOCKER_REGISTRY:-itisfoundation}/sidecar:${DOCKER_IMAGE_TAG:-latest}
    init: true
    deploy:
      mode: replicated
      replicas: 8
      endpoint_mode: dnsrr
      resources:
        reservations:
          cpus: "0.1"
          memory: "100M"
    volumes:
      - input:/home/scu/input
      - output:/home/scu/output
      - log:/home/scu/log
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - START_AS_MODE_GPU=1
      - RABBIT_HOST=${RABBIT_HOST}
      - RABBIT_PORT=${RABBIT_PORT}
      - RABBIT_USER=${RABBIT_USER}
      - RABBIT_PASSWORD=${RABBIT_PASSWORD}
      - RABBIT_CHANNELS=${RABBIT_CHANNELS}
      - POSTGRES_ENDPOINT=${POSTGRES_ENDPOINT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_HOST=${POSTGRES_HOST}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - S3_ENDPOINT=${S3_ENDPOINT}
      - S3_ACCESS_KEY=${S3_ACCESS_KEY}
      - S3_SECRET_KEY=${S3_SECRET_KEY}
      - S3_BUCKET_NAME=${S3_BUCKET_NAME}
      - STORAGE_ENDPOINT=${STORAGE_ENDPOINT}
      - REGISTRY_URL=${REGISTRY_URL}
      - REGISTRY_USER=${REGISTRY_USER}
      - REGISTRY_PW=${REGISTRY_PW}
      - SWARM_STACK_NAME=${SWARM_STACK_NAME:-simcore}
      - SIDECAR_LOGLEVEL=${LOG_LEVEL:-WARNING}
    depends_on:
      - rabbit
      - postgres
    networks:
      - computational_services_subnet

  postgres:
    ports:
      - "5432:5432"
    # https://www.postgresql.org/docs/10/runtime-config-logging.html#GUC-LOG-STATEMENT
    command:
      [
        "postgres",
        "-c",
        "tcp_keepalives_idle=600",
        "-c",
        "tcp_keepalives_interval=600",
        "-c",
        "tcp_keepalives_count=5",
        "-c",
        "log_statement=all",
        "-c",
        "log_connections=true",
        "-c",
        "log_disconnections=true",
        "-c",
        "log_duration=true",
        "-c",
        "log_line_prefix=%m [%p] %q%u@%d/%a ",
      ]

  rabbit:
    ports:
      - "5672"
      - "15672"
      - "15692"

  redis:
    ports:
      - "6379"

  traefik:
    ports:
      - target: 80
        published: 9081
      - target: 8080
        published: 8080
    deploy:
      labels:
        # traefik dashboard UI accessible through http://127.0.0.1:8080/dashboard/
        # traefik REST API accessible through for example http://127.0.0.1:8080/api/http/routers
        - io.simcore.zone=${TRAEFIK_SIMCORE_ZONE}
        - traefik.enable=true
        - traefik.http.routers.${SWARM_STACK_NAME}_api_internal.service=api@internal
        - traefik.http.routers.${SWARM_STACK_NAME}_api_internal.rule=PathPrefix(`/dashboard`) || PathPrefix(`/api`)
        - traefik.http.routers.${SWARM_STACK_NAME}_api_internal.entrypoints=traefik_monitor
        - traefik.http.routers.${SWARM_STACK_NAME}_api_internal.middlewares=gzip@docker
        - traefik.http.services.${SWARM_STACK_NAME}_api_internal.loadbalancer.server.port=8080

  whoami:
    image: "containous/whoami"
    # NOTE: helper service allows to better understand how the host gets forwarded inside the simcore stack
    deploy:
      labels:
        # whoami accessible through http://127.0.0.1:8080/whoami
        - io.simcore.zone=${TRAEFIK_SIMCORE_ZONE}
        - traefik.enable=true
        - traefik.http.services.${SWARM_STACK_NAME}_whoami.loadbalancer.server.port=80
        - traefik.http.routers.${SWARM_STACK_NAME}_whoami.rule=PathPrefix(`/whoami`)
        - traefik.http.routers.${SWARM_STACK_NAME}_whoami.entrypoints=traefik_monitor
        - traefik.http.routers.${SWARM_STACK_NAME}_whoami.middlewares=gzip@docker
